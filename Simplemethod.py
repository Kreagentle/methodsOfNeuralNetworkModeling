# Идентификация правой части нестационарной одномерной задачи при неизвестной зависимости от времени
# Алгоритм трехточечной прогонки
import numpy as np
import math as m
import random
import matplotlib. pyplot as plt
from datetime import datetime

start = datetime.now()
# прямая задача
DELTA=0.001 # уровень погрешности во входных данных
N=100 # число узлов сетки по пространству 
M=100 # число узлов сетки по времени
    
VT = np.zeros(M+1) # точная зависимость правой части от времени
VY = np.zeros(M+1) # точное решение в точке наблюдения
VP = np.zeros(M+1) # возмущенное решение в точке наблюдения
VV = np.zeros(M+1) # рассчитаная зависимость правой части от времени
A = np.zeros(N+1) 
B = np.zeros(N+1) 
C = np.zeros(N+1) 
F = np.zeros(N+1) 
Y = np.zeros(N+1)
VB = np.zeros(N+1) # зависимость правой части от пространства
FB = np.zeros(N+1) 
W = np.zeros(N+1) 
Z = np.zeros(N+1)

XL = 0 # левый конец отрезка
XR = 1 # правый конец отрезка
XD = 0.3 # точка наблюдения
TMAX = 1 # максимальное время 

# сетка (посмотреть как тут работает)
H = (XR - XL) / (N - 1)
TAU = TMAX / (M - 1)
ND = int(1 + (XD + 0.5*H) / H) # количество шагов до точки налюдения

# ПРЯМАЯ ЗАДАЧА

# источник (нормально работает)
for K in range(1,M+1):
        T = (K - 0.5) * TAU # время, за которое мы дошли до K-того узла
        VT[K] = (K - 0.5) * TAU
        if (T >= 0.6): 
            VT[K] = 0
    
# зависимость правой части от пространства (вот тут возникают вопросы)
for I in range(1, N+1):
        VB[I] = m.sin(m.pi*(I-1)*H) # x - дистанция для нулевого узла
        
# начальное условие задачи (предположим, тут все так, как должно быть)
Т = 0
for I in range (1, N+1): # зануляем Y, предположительно, Y - это ответ
    Y[I] = 0
    
VY[1] = Y[ND] # зануляем точное решение в точке наблюдения

# новый временной слой
for K in range (2, M+1):
        Т = Т + TAU 
        
        # коэффициенты разностной схемы
        for I in range (2 , N):
            A[I] = 1 / (H*H)
            B[I] = 1 / (H*H)
            C[I] = 2 / (H*H) + 1 / TAU
        
        # граничное условие на левом и правом конце
        B[1] = 0
        C[1] = 1
        F[1] = 0
        A[N] = 0
        C[N] = 1
        F[N] = 0
        
        # правая часть сеточного уравнения
        for I in range (2, N):
            F[I] = VB[I]*VT[K] + Y[I] / TAU
        
        # решение задачи на новом временном слое
        # метод прогонки для трехдиагональной матрицы
        # prog3 возможны ошибки перепроверить
        B[1] = B[1] / C[1] # нормируем вектора между собой
        for I in range (2, N+1):
            C[I] = C[I] - B[I-1]*A[I]
            B[I]= B[I] / C[I]

        F[1] = F[1] / C[1]
        for I in range (2, N+1):
            F[I] = (F[I] + F[I-1]*A[I]) / C[I]

        Y[N] = F[N]
        for I in range(N-1, 0, -1):
            Y[I] = B[I]*Y[I+1] + F[I] # все-таки решение
            
        VY[K] = Y[ND] # сохраняем решение
        
# возмущение измеряемых величин        
for K in range (1,M+1):
        VP[K] = VY[K] + 2*DELTA*(random.random() - 0.5) # функция зашумляется, что делать

# ОБРАТНАЯ ЗАДАЧА
# вспомогательная функция
for I in range (2, N):
        FB[I] = (1 / VB[ND]) * (VB[I+1]-2*VB[I] + VB[I-1]) / (H*H) # CHECK IT
        # print(FB)
        
# начальное условие        
Т = 0
for I in range (1, N+1):
    Y[I] = 0

# новый временной слой
for K in range (2, M+1):
        Т = Т + TAU
        
        # коэффициенты разностной системы
        for I in range (2, N):
            A[I] = 1 / (H*H)
            B[I] = 1 / (H*H)
            C[I] = 2 / (H*H) + 1 / TAU
        
        # граничное условие на левом и правом концах
        B[1] = 0
        C[1] = 1
        F[1] = 0
        A[N] = 0
        C[N] = 1
        F[N] = 0
        
        # правая часть сеточного уравнения
        for I in range (2, N):
            F[I] = FB[I]*VY[K] + Y[I] / TAU
        
        # решение первой подзадачи на новом временном слое
        # метод прогонки для трехдиагональной матрицы
        # prog3 возможны ошибки перепроверить
        B[1] = B[1] / C[1]
        for I in range (2, N+1):
            C[I] = C[I] - B[I-1]*A[I]
            B[I]= B[I] / C[I]

        F[1] = F[1] / C[1]
        for I in range (2, N+1):
            F[I] = (F[I] + F[I-1]*A[I]) / C[I]

        W[N] = F[N]
        for I in range(N-1, 0, -1):
            W[I] = B[I]*W[I+1] + F[I]
        
        # коэффициенты разностной системы
        for I in range (2, N):
            A[I] = 1 / (H*H)
            B[I] = 1 / (H*H)
            C[I] = 2 / (H*H) + 1 / TAU
        
        # граничное условие на левом и правом концах 
        B[1] = 0
        C[1] = 1
        F[1] = 0
        A[N] = 0
        C[N] = 1
        F[N] = 0
        
        # правая часть сеточного уравнения
        for I in range (2, N):
            F[I] = - FB[I]
        
        # решение второй подзадачи на новом временном слое
        # метод прогонки для трехдиагональной матрицы
        # prog3 возможны ошибки перепроверить
        B[1] = B[1] / C[1]
        for I in range (2, N+1):
            C[I] = C[I] - B[I-1]*A[I]
            B[I]= B[I] / C[I]

        F[1] = F[1] / C[1]
        for I in range (2, N+1):
            F[I] = (F[I] + F[I-1]*A[I]) / C[I]

        Z[N] = F[N]
        for I in range(N-1, 0, -1): # think about this change
            Z[I] = B[I]*Z[I+1] + F[I]
            
        VV[K] = (VP[K] - VP[K-1] - (W[ND] / (1 - Z[ND]) - Y[ND] )) / (TAU * VB[ND]) # CHECK IT
        
        for I in range (1, N+1):
            Y[I] = W[I] + Z[I] * W[ND] / (1 - Z[ND])


print(datetime.now() - start)
# вывод
x = np.linspace(0, 1, 101)
plt.plot(x, VT, color='pink')  # точная зависимость правой части от времени
plt.plot(x, VV, color='blue')  # рассчитаная зависимость правой части от времени
# plt.plot(x, VY, color='green') # точное решение в точке наблюдения
# plt.plot(x, VP, color='red')   # возмущенное решение в точке наблюдения
# plt.plot(x, VB, color='black') # зависимость правой части от пространства
plt.plot(x, VT, 'b-', label='точное')
plt.plot(x, VV, 'r-', label='приближенное')
plt.legend(loc='upper right')
plt.show()

print(x)
def mse_loss(y_true, y_pred):
    # y_true и y_pred являются массивами numpy с одинаковой длиной
    return ((y_true - y_pred) ** 2).mean()

print(mse_loss(VT, VV))
print("Точная зависимость:")
print(VT)
print("Рассчитанная зависимость:")
print(VV)